[{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"hexsmoothR implements hexagonal grid-based spatial smoothing algorithms optimized environmental data analysis. vignette demonstrates complete workflow data preparation hexagonal grid creation, data extraction, spatial smoothing. hexagonal approach provides superior spatial averaging compared traditional square-grid methods, particularly complex spatial patterns environmental data.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"hexagonal-grid-advantages","dir":"Articles","previous_headings":"","what":"Hexagonal Grid Advantages","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Hexagonal grids offer several technical advantages spatial analysis: Six neighbors per cell vs. four square grids Eliminates diagonal artifacts edge effects Improved packing efficiency uniform cell shapes Consistent neighbor distances spatial averaging","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"coastal-data-demonstration","dir":"Articles","previous_headings":"","what":"Coastal Data Demonstration","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Coastal vegetation data demonstrates hexagonal smoothing effectiveness: Complex, irregular shorelines challenging traditional grid methods Natural noise water interference, cloud cover, sensor issues Underlying environmental patterns suitable spatial enhancement Clear visualization smoothing algorithm performance","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"workflow-overview","dir":"Articles","previous_headings":"","what":"Workflow Overview","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"complete hexagonal smoothing workflow: Data preparation validation Hexagonal grid creation appropriate cell sizing Raster data extraction hexagonal cells Spatial topology setup neighbor relationships Weighted smoothing algorithm application Result analysis visualization","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"data-source-and-characteristics","dir":"Articles","previous_headings":"","what":"Data Source and Characteristics","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Sentinel-2 L2A NDVI data Copernicus Hub Ecosystem provides authentic coastal vegetation patterns. NDVI values range -0.8 (water/bare soil) 1.6+ (dense vegetation). demonstration uses original Sentinel-2 data without artificial noise, demonstrating hexagonal smoothing authentic environmental patterns. algorithm enhances spatial patterns neighbor averaging preserving underlying environmental signals.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"algorithm-implementation","dir":"Articles","previous_headings":"","what":"Algorithm Implementation","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"hexagonal smoothing algorithm implements weighted neighbor averaging: First-order neighbors: Directly adjacent hexagons Second-order neighbors: Neighbors first-order neighbors Weighted averaging: Center cell neighbors contribute according specified weights Spatial preservation: Underlying patterns maintained smoothing following sections provide implementation examples technical details workflow step.","code":""},{"path":[]},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"coordinate-reference-systems-crs","dir":"Articles","previous_headings":"Key Concepts and Implementation Details","what":"Coordinate Reference Systems (CRS)","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"CRS selection affects hexagonal grid accuracy cell sizing: Projected CRS (UTM, State Plane): cell_size meters Geographic CRS (WGS84, NAD83): cell_size degrees Package handles CRS transformations automatically Production use: UTM coordinates cell sizes meters","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"hexagon-geometry-and-measurements","dir":"Articles","previous_headings":"Key Concepts and Implementation Details","what":"Hexagon Geometry and Measurements","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"cell_size parameter: flat--flat distance (opposite edges) Pointy-topped hexagons: default configuration neighbor calculations Helper functions: convert measurement systems Regular hexagons: consistent area ratios neighbor distances","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"spatial-topology-and-neighbor-relationships","dir":"Articles","previous_headings":"Key Concepts and Implementation Details","what":"Spatial Topology and Neighbor Relationships","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"First-order neighbors: directly adjacent hexagons sharing edges Second-order neighbors: neighbors first-order neighbors Weight parameters: control center vs. neighbor cell influence Implementation: weights applied individual neighbors, neighbor means Spatial topology determines smoothing algorithm behavior. hexagon receives weighted average value plus neighbor values, weights controlling local vs. neighborhood information balance.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-1-library-loading-and-data-preparation","dir":"Articles","previous_headings":"","what":"Step 1: Library Loading and Data Preparation","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"library(hexsmoothR) library(sf) library(terra) library(exactextractr)  # Define area of interest for coastal analysis bbox <- st_bbox(   c(xmin = -122.50, ymin = 47.62, xmax = -122.54, ymax = 47.63),   crs = st_crs(4326) )  aoi_sf <- st_as_sf(st_as_sfc(bbox)) cat(\"AOI: Puget Sound coastal region\\n\") #> AOI: Puget Sound coastal region  # Load Sentinel-2 L2A NDVI data or fallback to simulated data sentinel_file <- system.file(\"extdata\", \"sentinel2_ndvi.tif\", package = \"hexsmoothR\") if (file.exists(sentinel_file)) {   true_coastal_vegetation <- rast(sentinel_file)    cat(\"Sentinel-2 L2A NDVI data loaded\\n\") } else {   cat(\"Using simulated coastal vegetation data\\n\")      # Create a simple simulated elevation raster for demonstration   set.seed(42)   true_elevation <- rast(nrows = 100, ncols = 100,                           xmin = -122.54, xmax = -122.50,                           ymin = 47.62, ymax = 47.63,                           crs = \"EPSG:4326\")      # Simulate elevation with coastal gradient   x_coords <- seq(-122.54, -122.50, length.out = 100)   y_coords <- seq(47.62, 47.63, length.out = 100)   coords <- expand.grid(x = x_coords, y = y_coords)      # Create elevation pattern: higher inland, lower near coast   elevation_values <- 50 + 100 * (coords$x - min(coords$x)) / (max(coords$x) - min(coords$x)) +                      30 * (coords$y - min(coords$y)) / (max(coords$y) - min(coords$y)) +                      rnorm(nrow(coords), 0, 10)      values(true_elevation) <- elevation_values      # Simulate coastal vegetation pattern based on elevation   vegetation_from_elev <- 1 - (true_elevation / 200)   distance_effect <- (true_elevation - min(values(true_elevation), na.rm = TRUE)) /                      (max(values(true_elevation), na.rm = TRUE) - min(values(true_elevation), na.rm = TRUE))   vegetation_from_distance <- 1 - distance_effect * 0.6      set.seed(42)   coastal_patches <- rast(true_elevation)   values(coastal_patches) <- runif(ncell(true_elevation), 0, 0.3)      true_coastal_vegetation <- vegetation_from_elev + vegetation_from_distance + coastal_patches   true_coastal_vegetation[true_coastal_vegetation < 0.1] <- 0.1   true_coastal_vegetation[true_coastal_vegetation > 0.8] <- 0.8 } #> Sentinel-2 L2A NDVI data loaded  # Use original data for hexagonal smoothing demonstration observed_coastal_vegetation <- true_coastal_vegetation  # Data summary if (file.exists(sentinel_file)) {   cat(\"Sentinel-2 L2A NDVI data loaded\\n\") } else {   cat(\"Simulated coastal vegetation data\\n\") } #> Sentinel-2 L2A NDVI data loaded cat(\"Dimensions:\", nrow(observed_coastal_vegetation), \"x\", ncol(observed_coastal_vegetation), \"pixels\\n\") #> Dimensions: 176 x 292 pixels cat(\"Resolution:\", round(xres(observed_coastal_vegetation) * 111320, 1), \"m\\n\") #> Resolution: 20 m cat(\"CRS:\", crs(observed_coastal_vegetation, proj = TRUE), \"\\n\") #> CRS: +proj=longlat +datum=WGS84 +no_defs missing_pct <- round(global(is.na(observed_coastal_vegetation), \"mean\")$mean * 100, 1) cat(\"Missing values:\", missing_pct, \"%\\n\") #> Missing values: 0 0 0 %  # Create color palette for NDVI visualization plot_colors <- colorRampPalette(c(\"darkred\", \"red\", \"orange\", \"yellow\", \"green\", \"darkgreen\"))(100) cat(\"Color palette: 100 colors (red to green)\\n\") #> Color palette: 100 colors (red to green)  # Plot 1: True underlying coastal vegetation pattern (NDVI-like) if (file.exists(sentinel_file)) {   plot_title_1 <- \"Real Sentinel-2 L2A Coastal Vegetation Pattern (NDVI)\\nThe signal to recover\" } else {   plot_title_1 <- \"True Coastal Vegetation Pattern (NDVI-like)\\nThe signal to recover\" }  plot(true_coastal_vegetation$sentinel2_ndvi_1,       main = plot_title_1,      col = plot_colors,      axes = FALSE) # Plot 2: Observed coastal vegetation data if (file.exists(sentinel_file)) {   plot_title_2 <- \"Observed Coastal Vegetation Data (NDVI)\\nOriginal Sentinel-2 data\" } else {   plot_title_2 <- \"Observed Coastal Vegetation Data (NDVI-like)\\nSimulated data\" }  plot(observed_coastal_vegetation$sentinel2_ndvi_3,      main = plot_title_2,      col = plot_colors,      axes = FALSE) cat(\"Individual plots created successfully!\\n\") #> Individual plots created successfully!  demo_raster <- observed_coastal_vegetation"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-2-hexagonal-grid-creation","dir":"Articles","previous_headings":"","what":"Step 2: Hexagonal Grid Creation","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Grid creation requires appropriate cell sizing coordinate system selection. Cell size determines spatial resolution computational requirements.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"cell-size-and-crs-dependencies","dir":"Articles","previous_headings":"Step 2: Hexagonal Grid Creation","what":"Cell Size and CRS Dependencies","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Cell size units depend coordinate reference system: Projected CRS (UTM, State Plane): cell_size meters Geographic CRS (WGS84, NAD83): cell_size degrees Use projected CRS (UTM) accurate measurements.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"cell-size-calculation","dir":"Articles","previous_headings":"Step 2: Hexagonal Grid Creation","what":"Cell Size Calculation","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Calculate cell size match target hexagon count raster area.","code":"# Create study area polygon from raster extent study_area_wgs <- st_sf(geometry = st_sfc(   st_polygon(list(matrix(     c(ext(demo_raster)[1], ext(demo_raster)[3],  # xmin, ymin       ext(demo_raster)[2], ext(demo_raster)[3],  # xmax, ymin       ext(demo_raster)[2], ext(demo_raster)[4],  # xmax, ymax       ext(demo_raster)[1], ext(demo_raster)[4],  # xmin, ymax       ext(demo_raster)[1], ext(demo_raster)[3]), # back to start     ncol = 2, byrow = TRUE   ))), crs = 4326))  cat(\"Study area CRS: WGS84\\n\") #> Study area CRS: WGS84  # Transform to UTM for accurate measurements utm_crs <- get_utm_crs(study_area_wgs) study_area_utm <- st_transform(study_area_wgs, utm_crs)  cat(\"UTM CRS:\", st_crs(study_area_utm)$input, \"\\n\") #> UTM CRS: EPSG:32610  # Calculate cell size for target hexagon count # Convert degrees to meters (111320 factor, varies by latitude) raster_area_km2 <- (nrow(demo_raster) * ncol(demo_raster) * (xres(demo_raster) * 111320/1000) * (yres(demo_raster) * 111320/1000))  # Target hexagon count for spatial resolution target_cells <- 5000  # Calculate cell size using hexagon area ratio (2.598) cell_size_meters <- sqrt((raster_area_km2 * 1e6) / (target_cells * 2.598))  cat(\"Raster area:\", round(raster_area_km2, 1), \"km²\\n\") #> Raster area: 13.9 km² cat(\"Target hexagons:\", target_cells, \"\\n\") #> Target hexagons: 5000 cat(\"Cell size:\", round(cell_size_meters, 0), \"m (\", round(cell_size_meters/1000, 1), \"km)\\n\") #> Cell size: 33 m ( 0 km)  hex_grid <- create_grid(study_area_utm, cell_size = cell_size_meters, type = \"hexagonal\") #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 11223 cells  cat(\"Grid created:\", nrow(hex_grid), \"cells\\n\") #> Grid created: 11223 cells cat(\"Average cell area:\", round(mean(st_area(hex_grid)) / 1e6, 1), \"km²\\n\") #> Average cell area: 0 km²  # Transform to WGS84 for raster compatibility hex_grid_wgs84 <- st_transform(hex_grid, crs = 4326)  # Visualize grid overlay par(mfrow = c(1, 2))  plot(demo_raster$sentinel2_ndvi_1, main = \"Data with Hexagonal Grid\") plot(st_geometry(hex_grid_wgs84), add = TRUE, border = \"white\", lwd = 0.1)  plot(st_geometry(hex_grid_wgs84), main = paste(\"Hexagonal Grid -\", nrow(hex_grid), \"cells\"),       border = \"blue\", lwd = 0.05)"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"helper-function-for-optimal-cell-size","dir":"Articles","previous_headings":"Step 2: Hexagonal Grid Creation","what":"Helper Function for Optimal Cell Size","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Package suggests optimal cell size for target hexagon count target_cells <- 5000 optimal_cell_size <- find_hex_cell_size_for_target_cells(   study_area_utm,    target_cells = target_cells,    cell_size_min = 20,     cell_size_max = 40 ) #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 29800 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7553 cells #> [find_hex_cell_size_for_target_cells] n_cells at min (20.0000): 29800 #> [find_hex_cell_size_for_target_cells] n_cells at max (40.0000): 7553 #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 13340 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 9838 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 8584 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 8044 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7796 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7675 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7618 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7586 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7570 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7562 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7557 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7554 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7555 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7555 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7554 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7554 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7554 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7553 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7553 cells #>   Creating hexagonal grid... #>   Cropping grid... #>   Clipping grid... #>   Transforming CRS... #>   Grid created with 7553 cells #> [find_hex_cell_size_for_target_cells] Closest found: 39.9999 (diff: 2553)  cat(\"Optimal cell size:\", round(optimal_cell_size, 0), \"m\\n\") #> Optimal cell size: 40 m"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"import-existing-grid","dir":"Articles","previous_headings":"Step 2: Hexagonal Grid Creation","what":"Import Existing Grid","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Load existing hexagonal grid and ensure correct CRS existing_grid <- st_read(\"path/to/your/hex_grid.shp\")  if (st_crs(existing_grid)$input != st_crs(study_area_utm)$input) {   existing_grid <- st_transform(existing_grid, crs = st_crs(study_area_utm)) }  hex_grid <- existing_grid"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-3-extract-raster-data-into-hexagons","dir":"Articles","previous_headings":"","what":"Step 3: Extract Raster Data into Hexagons","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Extract raster values hexagon cells using existing grid.","code":"# Extract raster values into hexagon cells # Function handles CRS transformations and pixel aggregation  cat(\"Raster data extraction\\n\") #> Raster data extraction cat(\"Using existing grid (cell_size = NULL)\\n\") #> Using existing grid (cell_size = NULL)  # Extract raster values using existing hexagonal grid extracted_data <- extract_raster_data(   raster_files = list(coastal_vegetation = demo_raster),   hex_grid = hex_grid_wgs84,   cell_size = NULL ) #> Extracting raster data from 1 terra::rast objects... #> First raster object: coastal_vegetation  #> Dimensions: 176 x 292  #> Resolution: 0.0001798288 0.0001215511  #> CRS: GEOGCRS[\"WGS 84\", #>     ENSEMBLE[\"World Geodetic System 1984 ensemble\", #>         MEMBER[\"World Geodetic System 1984 (Transit)\"], #>         MEMBER[\"World Geodetic System 1984 (G730)\"], #>         MEMBER[\"World Geodetic System 1984 (G873)\"], #>         MEMBER[\"World Geodetic System 1984 (G1150)\"], #>         MEMBER[\"World Geodetic System 1984 (G1674)\"], #>         MEMBER[\"World Geodetic System 1984 (G1762)\"], #>         MEMBER[\"World Geodetic System 1984 (G2139)\"], #>         ELLIPSOID[\"WGS 84\",6378137,298.257223563, #>             LENGTHUNIT[\"metre\",1]], #>         ENSEMBLEACCURACY[2.0]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"geodetic latitude (Lat)\",north, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>         AXIS[\"geodetic longitude (Lon)\",east, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>     USAGE[ #>         SCOPE[\"Horizontal component of 3D system.\"], #>         AREA[\"World.\"], #>         BBOX[-90,-180,90,180]], #>     ID[\"EPSG\",4326]]  #> No study area provided. Using raster CRS for grid creation. #> Using provided hexagonal grid... #> Processing coastal_vegetation ... #>   |                                                                              |                                                                      |   0%  |                                                                              |                                                                      |   1%  |                                                                              |=                                                                     |   1%  |                                                                              |=                                                                     |   2%  |                                                                              |==                                                                    |   2%  |                                                                              |==                                                                    |   3%  |                                                                              |==                                                                    |   4%  |                                                                              |===                                                                   |   4%  |                                                                              |===                                                                   |   5%  |                                                                              |====                                                                  |   5%  |                                                                              |====                                                                  |   6%  |                                                                              |=====                                                                 |   6%  |                                                                              |=====                                                                 |   7%  |                                                                              |=====                                                                 |   8%  |                                                                              |======                                                                |   8%  |                                                                              |======                                                                |   9%  |                                                                              |=======                                                               |   9%  |                                                                              |=======                                                               |  10%  |                                                                              |=======                                                               |  11%  |                                                                              |========                                                              |  11%  |                                                                              |========                                                              |  12%  |                                                                              |=========                                                             |  12%  |                                                                              |=========                                                             |  13%  |                                                                              |=========                                                             |  14%  |                                                                              |==========                                                            |  14%  |                                                                              |==========                                                            |  15%  |                                                                              |===========                                                           |  15%  |                                                                              |===========                                                           |  16%  |                                                                              |============                                                          |  16%  |                                                                              |============                                                          |  17%  |                                                                              |============                                                          |  18%  |                                                                              |=============                                                         |  18%  |                                                                              |=============                                                         |  19%  |                                                                              |==============                                                        |  19%  |                                                                              |==============                                                        |  20%  |                                                                              |==============                                                        |  21%  |                                                                              |===============                                                       |  21%  |                                                                              |===============                                                       |  22%  |                                                                              |================                                                      |  22%  |                                                                              |================                                                      |  23%  |                                                                              |================                                                      |  24%  |                                                                              |=================                                                     |  24%  |                                                                              |=================                                                     |  25%  |                                                                              |==================                                                    |  25%  |                                                                              |==================                                                    |  26%  |                                                                              |===================                                                   |  26%  |                                                                              |===================                                                   |  27%  |                                                                              |===================                                                   |  28%  |                                                                              |====================                                                  |  28%  |                                                                              |====================                                                  |  29%  |                                                                              |=====================                                                 |  29%  |                                                                              |=====================                                                 |  30%  |                                                                              |=====================                                                 |  31%  |                                                                              |======================                                                |  31%  |                                                                              |======================                                                |  32%  |                                                                              |=======================                                               |  32%  |                                                                              |=======================                                               |  33%  |                                                                              |=======================                                               |  34%  |                                                                              |========================                                              |  34%  |                                                                              |========================                                              |  35%  |                                                                              |=========================                                             |  35%  |                                                                              |=========================                                             |  36%  |                                                                              |==========================                                            |  36%  |                                                                              |==========================                                            |  37%  |                                                                              |==========================                                            |  38%  |                                                                              |===========================                                           |  38%  |                                                                              |===========================                                           |  39%  |                                                                              |============================                                          |  39%  |                                                                              |============================                                          |  40%  |                                                                              |============================                                          |  41%  |                                                                              |=============================                                         |  41%  |                                                                              |=============================                                         |  42%  |                                                                              |==============================                                        |  42%  |                                                                              |==============================                                        |  43%  |                                                                              |==============================                                        |  44%  |                                                                              |===============================                                       |  44%  |                                                                              |===============================                                       |  45%  |                                                                              |================================                                      |  45%  |                                                                              |================================                                      |  46%  |                                                                              |=================================                                     |  46%  |                                                                              |=================================                                     |  47%  |                                                                              |=================================                                     |  48%  |                                                                              |==================================                                    |  48%  |                                                                              |==================================                                    |  49%  |                                                                              |===================================                                   |  49%  |                                                                              |===================================                                   |  50%  |                                                                              |===================================                                   |  51%  |                                                                              |====================================                                  |  51%  |                                                                              |====================================                                  |  52%  |                                                                              |=====================================                                 |  52%  |                                                                              |=====================================                                 |  53%  |                                                                              |=====================================                                 |  54%  |                                                                              |======================================                                |  54%  |                                                                              |======================================                                |  55%  |                                                                              |=======================================                               |  55%  |                                                                              |=======================================                               |  56%  |                                                                              |========================================                              |  56%  |                                                                              |========================================                              |  57%  |                                                                              |========================================                              |  58%  |                                                                              |=========================================                             |  58%  |                                                                              |=========================================                             |  59%  |                                                                              |==========================================                            |  59%  |                                                                              |==========================================                            |  60%  |                                                                              |==========================================                            |  61%  |                                                                              |===========================================                           |  61%  |                                                                              |===========================================                           |  62%  |                                                                              |============================================                          |  62%  |                                                                              |============================================                          |  63%  |                                                                              |============================================                          |  64%  |                                                                              |=============================================                         |  64%  |                                                                              |=============================================                         |  65%  |                                                                              |==============================================                        |  65%  |                                                                              |==============================================                        |  66%  |                                                                              |===============================================                       |  66%  |                                                                              |===============================================                       |  67%  |                                                                              |===============================================                       |  68%  |                                                                              |================================================                      |  68%  |                                                                              |================================================                      |  69%  |                                                                              |=================================================                     |  69%  |                                                                              |=================================================                     |  70%  |                                                                              |=================================================                     |  71%  |                                                                              |==================================================                    |  71%  |                                                                              |==================================================                    |  72%  |                                                                              |===================================================                   |  72%  |                                                                              |===================================================                   |  73%  |                                                                              |===================================================                   |  74%  |                                                                              |====================================================                  |  74%  |                                                                              |====================================================                  |  75%  |                                                                              |=====================================================                 |  75%  |                                                                              |=====================================================                 |  76%  |                                                                              |======================================================                |  76%  |                                                                              |======================================================                |  77%  |                                                                              |======================================================                |  78%  |                                                                              |=======================================================               |  78%  |                                                                              |=======================================================               |  79%  |                                                                              |========================================================              |  79%  |                                                                              |========================================================              |  80%  |                                                                              |========================================================              |  81%  |                                                                              |=========================================================             |  81%  |                                                                              |=========================================================             |  82%  |                                                                              |==========================================================            |  82%  |                                                                              |==========================================================            |  83%  |                                                                              |==========================================================            |  84%  |                                                                              |===========================================================           |  84%  |                                                                              |===========================================================           |  85%  |                                                                              |============================================================          |  85%  |                                                                              |============================================================          |  86%  |                                                                              |=============================================================         |  86%  |                                                                              |=============================================================         |  87%  |                                                                              |=============================================================         |  88%  |                                                                              |==============================================================        |  88%  |                                                                              |==============================================================        |  89%  |                                                                              |===============================================================       |  89%  |                                                                              |===============================================================       |  90%  |                                                                              |===============================================================       |  91%  |                                                                              |================================================================      |  91%  |                                                                              |================================================================      |  92%  |                                                                              |=================================================================     |  92%  |                                                                              |=================================================================     |  93%  |                                                                              |=================================================================     |  94%  |                                                                              |==================================================================    |  94%  |                                                                              |==================================================================    |  95%  |                                                                              |===================================================================   |  95%  |                                                                              |===================================================================   |  96%  |                                                                              |====================================================================  |  96%  |                                                                              |====================================================================  |  97%  |                                                                              |====================================================================  |  98%  |                                                                              |===================================================================== |  98%  |                                                                              |===================================================================== |  99%  |                                                                              |======================================================================|  99%  |                                                                              |======================================================================| 100% #>   Extracted 33669 valid values out of 3 total #> Extraction done! #> Total cells: 11223  #> Variables: coastal_vegetation  cat(\"Extraction complete:\", extracted_data$n_cells, \"cells\\n\") #> Extraction complete: 11223 cells cat(\"Variables:\", paste(extracted_data$variables, collapse = \", \"), \"\\n\") #> Variables: coastal_vegetation cat(\"Valid values:\", sum(!is.na(extracted_data$data$coastal_vegetation)), \"/\", nrow(extracted_data$data), \"\\n\") #> Valid values: 33669 / 11223  # Data statistics comparison original_mean <- mean(values(demo_raster), na.rm = TRUE) original_sd <- sd(values(demo_raster), na.rm = TRUE)  # Handle data structure if (is.list(extracted_data$data$coastal_vegetation)) {   extracted_values <- extracted_data$data$coastal_vegetation[[1]] } else {   extracted_values <- extracted_data$data$coastal_vegetation }  extracted_mean <- mean(extracted_values, na.rm = TRUE) extracted_sd <- sd(extracted_values, na.rm = TRUE)  cat(\"Data comparison:\\n\") #> Data comparison: cat(\"Original raster - Mean:\", round(original_mean, 3), \"SD:\", round(original_sd, 3), \"\\n\") #> Original raster - Mean: 0.169 SD: 0.232 cat(\"Extracted hexagons - Mean:\", round(extracted_mean, 3), \"SD:\", round(extracted_sd, 3), \"\\n\") #> Extracted hexagons - Mean: 0.119 SD: 0.202  # Visualize extraction results plot(demo_raster$sentinel2_ndvi_1,       main = paste(\"Original Raster (\", ncell(demo_raster), \"pixels)\"),      col = plot_colors) # Plot extracted hexagon values hex_for_plot <- hex_grid_wgs84 hex_for_plot$value <- extracted_values  # Use base R plotting for consistency plot(st_geometry(hex_for_plot),       col = plot_colors[cut(hex_for_plot$value, 100)],      main = paste(\"Extracted Hexagon Coastal Vegetation Values (NDVI-like)\\n(\", extracted_data$n_cells, \"hexagons)\"),      border = \"white\", lwd = 0.01) cat(\"\\nExtraction process:\\n\") #>  #> Extraction process: cat(\"- Left: Original coastal vegetation raster with\", ncell(demo_raster), \"pixels and noise\\n\")   #> - Left: Original coastal vegetation raster with 51392 pixels and noise cat(\"- Right: Extracted coastal vegetation values in\", extracted_data$n_cells, \"hexagons\\n\") #> - Right: Extracted coastal vegetation values in 11223 hexagons cat(\"- Each hexagon contains the average coastal vegetation of all pixels within its boundary\\n\") #> - Each hexagon contains the average coastal vegetation of all pixels within its boundary cat(\"- This aggregation already reduces some measurement noise!\\n\") #> - This aggregation already reduces some measurement noise! cat(\"- **PERFECT ALIGNMENT**: extract_raster_data preserves grid orientation like exact_extract\\n\") #> - **PERFECT ALIGNMENT**: extract_raster_data preserves grid orientation like exact_extract  # The extracted data contains: # - data: dataframe with extracted values # - variables: names of the extracted variables # - n_cells: number of grid cells"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"benefits-of-using-terrarast-objects","dir":"Articles","previous_headings":"Step 3: Extract Raster Data into Hexagons","what":"Benefits of Using terra::rast Objects","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Using terra::rast objects instead file paths provides several advantages: CRS Inspection: Check coordinate systems extraction Data Validation: Verify dimensions, extent, data quality Pre-processing: Apply filters, transformations, cropping extraction Memory Efficiency: Work -memory rasters repeated operations Error Prevention: Catch CRS data issues early workflow","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"example-working-with-multiple-rasters","dir":"Articles","previous_headings":"Step 3: Extract Raster Data into Hexagons","what":"Example: Working with Multiple Rasters","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Load multiple rasters for inspection ndvi_raster <- rast(\"path/to/ndvi.tif\") elevation_raster <- rast(\"path/to/elevation.tif\") precipitation_raster <- rast(\"path/to/precipitation.tif\")  # Inspect each raster cat(\"NDVI raster:\\n\") cat(\"  CRS:\", crs(ndvi_raster), \"\\n\") cat(\"  Dimensions:\", nrow(ndvi_raster), \"x\", ncol(ndvi_raster), \"\\n\")  cat(\"Elevation raster:\\n\") cat(\"  CRS:\", crs(elevation_raster), \"\\n\") cat(\"  Dimensions:\", nrow(elevation_raster), \"x\", ncol(elevation_raster), \"\\n\")  # Ensure all rasters have compatible CRS and extent if (crs(ndvi_raster) != crs(elevation_raster)) {   cat(\"Warning: Rasters have different CRS\\n\")   # You could reproject here if needed }  # Extract all variables at once extracted_multi <- extract_raster_data(   raster_files = list(     ndvi = ndvi_raster,     elevation = elevation_raster,     precipitation = precipitation_raster   ),   study_area = study_area_utm,   cell_size = 20000 )"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"working-examples-wgs84-vs-utm","dir":"Articles","previous_headings":"Step 3: Extract Raster Data into Hexagons","what":"Working Examples: WGS84 vs UTM","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Example 1: WGS84 coordinates (geographic) # Use degrees for cell_size extracted_wgs84 <- extract_raster_data(   raster_files = c(sample = sample_file),   study_area = study_area_wgs,  # WGS84 coordinates   cell_size = 0.1               # 0.1 degrees (~11km) )  # Example 2: UTM coordinates (projected) # Use meters for cell_size extracted_utm <- extract_raster_data(   raster_files = c(sample = sample_file),   study_area = study_area_utm,  # UTM coordinates   cell_size = 20000             # 20000 meters (20km) )  # Example 3: No study area (uses raster CRS) # Function automatically determines appropriate units extracted_auto <- extract_raster_data(   raster_files = c(sample = sample_file),   cell_size = 0.1               # 0.1 degrees (since raster is WGS84) )"},{"path":[]},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"standard-2-order-topology-backward-compatible","dir":"Articles","previous_headings":"Step 4: Configure Smoothing Topology","what":"Standard 2-Order Topology (Backward Compatible)","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Compute spatial topology for smoothing (default: 2 orders) topology <- compute_topology(hex_grid) #> Computing topology for area: grid with 2 neighbor orders #>   Computed: avg_dist = 32.22 m, orders = 2  cat(\"Topology computed:\", length(topology$neighbors[[1]]), \"cells\\n\") #> Topology computed: 11223 cells cat(\"Average distance:\", round(topology$avg_distance, 0), \"m\\n\") #> Average distance: 32 m cat(\"Sigma (bandwidth):\", round(topology$sigma, 0), \"m\\n\") #> Sigma (bandwidth): 16 m  cat(\"Gaussian weights:\\n\") #> Gaussian weights: cat(\"Center:\", round(topology$weights$center_weight, 3), \"\\n\") #> Center: 0.334 cat(\"First-order:\", round(topology$weights$neighbor_weights[1], 3), \"\\n\")  #> First-order: 0.334 cat(\"Second-order:\", round(topology$weights$neighbor_weights[2], 3), \"\\n\") #> Second-order: 0.332  # Weights applied to individual neighbors, not averages cat(\"Weights applied to each neighbor individually\\n\") #> Weights applied to each neighbor individually  # Neighbor examples cat(\"Cell 1:\", length(topology$neighbors[[1]][[1]]), \"1st,\", length(topology$neighbors[[2]][[1]]), \"2nd neighbors\\n\") #> Cell 1: 3 1st, 4 2nd neighbors cat(\"Cell 2:\", length(topology$neighbors[[1]][[2]]), \"1st,\", length(topology$neighbors[[2]][[2]]), \"2nd neighbors\\n\") #> Cell 2: 4 1st, 6 2nd neighbors cat(\"Cell 3:\", length(topology$neighbors[[1]][[3]]), \"1st,\", length(topology$neighbors[[2]][[3]]), \"2nd neighbors\\n\") #> Cell 3: 3 1st, 5 2nd neighbors  # Note: Visualization code would go here but requires actual grid objects cat(\"Neighborhood visualization would show:\\n\") #> Neighborhood visualization would show: cat(\"- Center cell (red)\\n\") #> - Center cell (red) cat(\"- 1st order neighbors (orange)\\n\")  #> - 1st order neighbors (orange) cat(\"- 2nd order neighbors (yellow)\\n\") #> - 2nd order neighbors (yellow)"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"advanced-n-order-topology-for-enhanced-smoothing","dir":"Articles","previous_headings":"Step 4: Configure Smoothing Topology","what":"Advanced: N-Order Topology for Enhanced Smoothing","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Compute topology with 3 neighbor orders for more extensive smoothing topology_3 <- compute_topology(hex_grid, neighbor_orders = 3) #> Computing topology for area: grid with 3 neighbor orders #>   Computed: avg_dist = 32.38 m, orders = 3  cat(\"3-Order topology computed:\", length(topology_3$neighbors[[1]]), \"cells\\n\") #> 3-Order topology computed: 11223 cells cat(\"Neighbor orders:\", topology_3$neighbor_orders, \"\\n\") #> Neighbor orders: 3  # Weight computation details cat(\"Average distance:\", round(topology_3$avg_distance, 0), \"m\\n\") #> Average distance: 32 m cat(\"Sigma (bandwidth):\", round(topology_3$sigma, 0), \"m\\n\") #> Sigma (bandwidth): 16 m  cat(\"Gaussian weights for 3 orders:\\n\") #> Gaussian weights for 3 orders: cat(\"Center:\", round(topology_3$weights$center_weight, 3), \"\\n\") #> Center: 0.252 for (i in 1:length(topology_3$weights$neighbor_weights)) {   cat(\"Order\", i, \":\", round(topology_3$weights$neighbor_weights[i], 3), \"\\n\") } #> Order 1 : 0.251  #> Order 2 : 0.25  #> Order 3 : 0.247  # Neighbor examples for (i in 1:min(3, length(topology_3$neighbors[[1]]))) {   cat(\"Cell\", i, \":\")   for (order in 1:3) {     n_neighbors <- length(topology_3$neighbors[[order]][[i]])     cat(\" \", n_neighbors, order, \"st\")   }   cat(\" neighbors\\n\") } #> Cell 1 :  3 1 st  4 2 st  6 3 st neighbors #> Cell 2 :  4 1 st  6 2 st  8 3 st neighbors #> Cell 3 :  3 1 st  5 2 st  6 3 st neighbors  # Custom weights for specific smoothing requirements topology_custom <- compute_topology(   hex_grid,    neighbor_orders = 4,   neighbor_weights_param = list(0.5, 0.3, 0.15, 0.05)  # Custom decay pattern ) #> Computing topology for area: grid with 4 neighbor orders #>   Computed: avg_dist = 32.59 m, orders = 4  cat(\"Custom 4-order topology with manual weights\\n\") #> Custom 4-order topology with manual weights cat(\"Total weight sum:\", topology_custom$weights$center_weight +      sum(topology_custom$weights$neighbor_weights), \"\\n\") #> Total weight sum: 1"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"understanding-neighbor-orders","dir":"Articles","previous_headings":"Step 4: Configure Smoothing Topology","what":"Understanding Neighbor Orders","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"neighbor order system determines far smoothing extends: 1st order: Directly touching cells (6 hexagons, 4 squares) 2nd order: Neighbors neighbors (typically 12 hexagons) 3rd order: Neighbors neighbors neighbors (typically 18 hexagons) Nth order: N levels neighbor relationships Higher orders provide extensive smoothing increase computation time memory usage. default 2-order system balances performance smoothing effectiveness applications.","code":""},{"path":[]},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"standard-2-order-smoothing-backward-compatible","dir":"Articles","previous_headings":"Step 5: Apply Spatial Smoothing","what":"Standard 2-Order Smoothing (Backward Compatible)","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Apply spatial smoothing using C++-optimized function (2 orders) smoothing_results <- smooth_variables(   variable_values = list(coastal_vegetation = extracted_values),   neighbors = topology$neighbors,   weights = topology$weights,   var_names = c(\"coastal_vegetation\") ) #> Using C++ implementation for N-order smoothing #> C++ implementation failed, falling back to R implementation:  \"_hexsmoothR_process_district_all_vars_n_orders\" not available for .Call() for package \"hexsmoothR\"  cat(\"Spatial smoothing complete\\n\") #> Spatial smoothing complete cat(\"Results:\", paste(names(smoothing_results$coastal_vegetation), collapse = \", \"), \"\\n\") #> Results: raw, weighted_combined, neighbors_1st, neighbors_2nd  # Example smoothing effectiveness analysis: cat(\"Smoothing effectiveness:\\n\") #> Smoothing effectiveness: cat(\"Original - Mean:\", round(mean(extracted_values, na.rm = TRUE), 3), \"SD:\", round(sd(extracted_values, na.rm = TRUE), 3), \"\\n\") #> Original - Mean: 0.119 SD: 0.202  cat(\"Smoothed coastal vegetation values:\\n\")   #> Smoothed coastal vegetation values: cat(\"  Mean:\", round(mean(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   Mean: 0.119 cat(\"  SD:\", round(sd(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   SD: 0.153  noise_reduction <- (sd(extracted_values, na.rm = TRUE) -                     sd(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE)) /                     sd(extracted_values, na.rm = TRUE) * 100  cat(\"Coastal vegetation noise reduction:\", round(noise_reduction, 1), \"%\\n\") #> Coastal vegetation noise reduction: 24.4 % cat(\"(Lower standard deviation = more consistent coastal vegetation patterns)\\n\") #> (Lower standard deviation = more consistent coastal vegetation patterns)  # The smoothing results contain: cat(\"\\n=== SMOOTHING RESULTS EXPLAINED ===\\n\") #>  #> === SMOOTHING RESULTS EXPLAINED === cat(\"- raw: Mean of center cell + all neighbors (unweighted)\\n\") #> - raw: Mean of center cell + all neighbors (unweighted) cat(\"- neighbors_1st: Average of first-order neighbors only\\n\")   #> - neighbors_1st: Average of first-order neighbors only cat(\"- neighbors_2nd: Average of second-order neighbors only\\n\") #> - neighbors_2nd: Average of second-order neighbors only cat(\"- weighted_combined: Weighted average (center + all neighbors) ★\\n\") #> - weighted_combined: Weighted average (center + all neighbors) ★ cat(\"\\n★ weighted_combined is typically the best result for noise reduction\\n\") #>  #> ★ weighted_combined is typically the best result for noise reduction"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"advanced-n-order-smoothing-for-enhanced-results","dir":"Articles","previous_headings":"Step 5: Apply Spatial Smoothing","what":"Advanced: N-Order Smoothing for Enhanced Results","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Apply 3-order smoothing using the new N-order system smoothing_results_3 <- smooth_variables(   variable_values = list(coastal_vegetation = extracted_values),   neighbors = topology_3$neighbors,   weights = topology_3$weights,   var_names = c(\"coastal_vegetation\") ) #> Using C++ implementation for N-order smoothing #> C++ implementation failed, falling back to R implementation:  \"_hexsmoothR_process_district_all_vars_n_orders\" not available for .Call() for package \"hexsmoothR\"  cat(\"3-Order spatial smoothing complete\\n\") #> 3-Order spatial smoothing complete cat(\"Results:\", paste(names(smoothing_results_3$coastal_vegetation), collapse = \", \"), \"\\n\") #> Results: raw, weighted_combined, neighbors_1st, neighbors_2nd, neighbors_3rd  # Compare 2-order vs 3-order smoothing cat(\"\\n=== COMPARING SMOOTHING APPROACHES ===\\n\") #>  #> === COMPARING SMOOTHING APPROACHES ===  # 2-order results cat(\"2-Order smoothing:\\n\") #> 2-Order smoothing: cat(\"  Mean:\", round(mean(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   Mean: 0.119 cat(\"  SD:\", round(sd(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   SD: 0.153  # 3-order results cat(\"3-Order smoothing:\\n\") #> 3-Order smoothing: cat(\"  Mean:\", round(mean(smoothing_results_3$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   Mean: 0.12 cat(\"  SD:\", round(sd(smoothing_results_3$coastal_vegetation$weighted_combined, na.rm = TRUE), 3), \"\\n\") #>   SD: 0.138  # Additional 3-order results available cat(\"\\n3-Order specific results:\\n\") #>  #> 3-Order specific results: cat(\"- neighbors_1st:\", round(mean(smoothing_results_3$coastal_vegetation$neighbors_1st, na.rm = TRUE), 3), \"\\n\") #> - neighbors_1st: 0.119 cat(\"- neighbors_2nd:\", round(mean(smoothing_results_3$coastal_vegetation$neighbors_2nd, na.rm = TRUE), 3), \"\\n\") #> - neighbors_2nd: 0.119 cat(\"- neighbors_3rd:\", round(mean(smoothing_results_3$coastal_vegetation$neighbors_3rd, na.rm = TRUE), 3), \"\\n\") #> - neighbors_3rd: 0.12  # Calculate additional noise reduction from 3-order smoothing noise_reduction_3 <- (sd(extracted_values, na.rm = TRUE) -                       sd(smoothing_results_3$coastal_vegetation$weighted_combined, na.rm = TRUE)) /                       sd(extracted_values, na.rm = TRUE) * 100  cat(\"3-Order noise reduction:\", round(noise_reduction_3, 1), \"%\\n\") #> 3-Order noise reduction: 31.8 % cat(\"Additional reduction over 2-order:\", round(noise_reduction_3 - noise_reduction, 1), \"%\\n\") #> Additional reduction over 2-order: 7.3 %"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"when-to-use-higher-orders","dir":"Articles","previous_headings":"Step 5: Apply Spatial Smoothing","what":"When to Use Higher Orders","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"2 orders (default): Best applications, balanced performance smoothing 3-4 orders: Use need extensive smoothing noisy data 5+ orders: Use sparingly large-scale patterns, aware increased computation time Custom weights: Use need specific spatial decay patterns analysis","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-6-combine-results-and-analyze","dir":"Articles","previous_headings":"","what":"Step 6: Combine Results and Analyze","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Combine the hexagonal grid with smoothing results hex_grid_with_results <- hex_grid hex_grid_with_results$coastal_vegetation_raw <- smoothing_results$coastal_vegetation$raw hex_grid_with_results$coastal_vegetation_neighbors_1st <- smoothing_results$coastal_vegetation$neighbors_1st hex_grid_with_results$coastal_vegetation_neighbors_2nd <- smoothing_results$coastal_vegetation$neighbors_2nd hex_grid_with_results$coastal_vegetation_weighted_combined <- smoothing_results$coastal_vegetation$weighted_combined  # Transform to WGS84 for plotting hex_grid_with_results_wgs84 <- st_transform(hex_grid_with_results, crs = 4326)  cat(\"Results combined with grid successfully\\n\") #> Results combined with grid successfully cat(\"Available columns:\", paste(names(hex_grid_with_results), collapse = \", \"), \"\\n\") #> Available columns: sf..st_make_grid.study_area_proj..cellsize...grid_size..square....type...., grid_id, grid_index, coastal_vegetation_raw, coastal_vegetation_neighbors_1st, coastal_vegetation_neighbors_2nd, coastal_vegetation_weighted_combined  # Analyze the smoothing effect cat(\"\\n=== SMOOTHING ANALYSIS ===\\n\") #>  #> === SMOOTHING ANALYSIS === cat(\"Understanding the smoothing results:\\n\") #> Understanding the smoothing results: cat(\"- raw: Mean of center cell + all neighbors (unweighted)\\n\") #> - raw: Mean of center cell + all neighbors (unweighted) cat(\"- neighbors_1st: Mean of first-order neighbors only\\n\") #> - neighbors_1st: Mean of first-order neighbors only cat(\"- neighbors_2nd: Mean of second-order neighbors only\\n\") #> - neighbors_2nd: Mean of second-order neighbors only cat(\"- weighted_combined: Weighted average (center + all neighbors, weights applied to each neighbor)\\n\\n\") #> - weighted_combined: Weighted average (center + all neighbors, weights applied to each neighbor)  # Example analysis output: cat(\"Original values - Count:\", length(extracted_values), \"Mean:\", round(mean(extracted_values, na.rm = TRUE), 4), \"SD:\", round(sd(extracted_values, na.rm = TRUE), 4), \"\\n\") #> Original values - Count: 11223 Mean: 0.1195 SD: 0.2021 cat(\"Smoothed values - Count:\", length(smoothing_results$coastal_vegetation$weighted_combined), \"Mean:\", round(mean(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 4), \"SD:\", round(sd(smoothing_results$coastal_vegetation$weighted_combined, na.rm = TRUE), 4), \"\\n\") #> Smoothed values - Count: 11223 Mean: 0.1195 SD: 0.1527 cat(\"Variance reduction:\", round(noise_reduction, 1), \"%\\n\") #> Variance reduction: 24.4 %"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-7-visualize-the-improvement","dir":"Articles","previous_headings":"","what":"Step 7: Visualize the Improvement","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# Create spectacular before/after visualization showing the power of spatial smoothing cat(\"=== CREATING BEFORE/AFTER VISUALIZATION ===\\n\") #> === CREATING BEFORE/AFTER VISUALIZATION ===  # Create visualization plots par(mfrow = c(2, 2))  # Plot 1: Original extracted values plot(st_geometry(hex_grid_wgs84),       col = plot_colors[cut(extracted_values, 100)],      main = \"Original Extracted Values\",      border = \"white\", lwd = 0.01)  # Plot 2: Smoothed values (1st order) plot(st_geometry(hex_grid_wgs84),       col = plot_colors[cut(smoothing_results$coastal_vegetation$neighbors_1st, 100)],      main = \"Smoothed (1st Order Neighbors)\",      border = \"white\", lwd = 0.01)  # Plot 3: Smoothed values (2nd order) plot(st_geometry(hex_grid_wgs84),       col = plot_colors[cut(smoothing_results$coastal_vegetation$neighbors_2nd, 100)],      main = \"Smoothed (2nd Order Neighbors)\",      border = \"white\", lwd = 0.01)  # Plot 4: Final weighted combined result plot(st_geometry(hex_grid_wgs84),       col = plot_colors[cut(smoothing_results$coastal_vegetation$weighted_combined, 100)],      main = \"Final Weighted Combined Result\",      border = \"white\", lwd = 0.01) cat(\"All visualization plots created successfully!\\n\") #> All visualization plots created successfully! cat(\"Progression shows:\\n\") #> Progression shows: cat(\"- Top left: Raw extracted data\\n\") #> - Top left: Raw extracted data cat(\"- Top right: 1st order neighbor smoothing\\n\") #> - Top right: 1st order neighbor smoothing cat(\"- Bottom left: 2nd order neighbor smoothing\\n\") #> - Bottom left: 2nd order neighbor smoothing cat(\"- Bottom right: Final weighted combined result\\n\") #> - Bottom right: Final weighted combined result"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-8-working-with-multiple-variables","dir":"Articles","previous_headings":"","what":"Step 8: Working with Multiple Variables","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# You can work with multiple raster files and variables raster_files <- c(   ndvi = \"path/to/your/ndvi.tif\",   elevation = \"path/to/your/elevation.tif\",   precipitation = \"path/to/your/precipitation.tif\" )  # Extract multiple variables extracted_multi <- extract_raster_data(   raster_files = raster_files,   study_area = study_area_utm,   cell_size = cell_size )  # Apply smoothing to all variables variable_values <- list(   ndvi = extracted_multi$data$ndvi,   elevation = extracted_multi$data$elevation,   precipitation = extracted_multi$data$precipitation )  smoothing_multi <- smooth_variables(   variable_values = variable_values,   neighbors = topology$neighbors,   weights = topology$weights,   var_names = c(\"ndvi\", \"elevation\", \"precipitation\") )  # Each variable gets the same smoothing treatment cat(\"Variables processed:\", paste(names(smoothing_multi), collapse = \", \"), \"\\n\")"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"step-9-hexagon-measurement-utilities","dir":"Articles","previous_headings":"","what":"Step 9: Hexagon Measurement Utilities","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"","code":"# The package provides helper functions for hexagon measurements # IMPORTANT: cell_size_flat is in METERS (UTM coordinates) cell_size_flat <- 20000  # 20km flat-to-flat distance in meters  # Convert between different hexagon measurements edge_length <- hex_flat_to_edge(cell_size_flat) circumradius <- hex_flat_to_circumradius(cell_size_flat)  cat(\"Hexagon measurements for\", cell_size_flat, \"m flat-to-flat distance:\\n\") #> Hexagon measurements for 20000 m flat-to-flat distance: cat(\"     - Edge length:\", round(edge_length, 2), \"m\\n\") #>      - Edge length: 11547.01 m cat(\"     - Circumradius:\", round(circumradius, 2), \"m\\n\") #>      - Circumradius: 11547.01 m  # Convert back flat_distance_from_edge <- hex_edge_to_flat(edge_length) flat_distance_from_circumradius <- hex_circumradius_to_flat(circumradius)  cat(\"Verification:\\n\") #> Verification: cat(\"Flat distance from edge:\", round(flat_distance_from_edge, 2), \"m\\n\") #> Flat distance from edge: 20000 m cat(\"Flat distance from circumradius:\", round(flat_distance_from_circumradius, 2), \"m\\n\") #> Flat distance from circumradius: 20000 m"},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"vignette demonstrates complete hexsmoothR workflow: Grid Creation: Create hexagonal grids projected coordinates (UTM recommended) Raster Extraction: Extract values raster files hexagon cells Topology Configuration: Set spatial relationships smoothing weights Spatial Smoothing: Apply C++-optimized smoothing algorithms Result Analysis: Visualize analyze smoothed hexagon layers","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"key-functions","dir":"Articles","previous_headings":"Summary","what":"Key Functions","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"create_grid() - Generate hexagonal grids optimal cell sizes extract_raster_data() - Extract raster values automatic CRS handling compute_topology() - Configure spatial relationships weights smooth_variables() - Apply fast spatial smoothing","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"helper-functions","dir":"Articles","previous_headings":"Summary","what":"Helper Functions","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"find_hex_cell_size_for_target_cells() - Optimize grid cell size get_utm_crs() - Automatically determine appropriate UTM projection hex_flat_to_edge(), hex_edge_to_flat() - Convert hexagon measurements","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"best-practices","dir":"Articles","previous_headings":"Summary","what":"Best Practices","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Always use projected CRS (UTM) grid creation Cell sizes meters using projected coordinates (UTM, State Plane, etc.) Cell sizes degrees using geographic coordinates (WGS84, NAD83, etc.) Let functions handle CRS transformations automatically Use helper functions optimize workflow","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/articles/hexsmoothR-complete-guide.html","id":"understanding-units-and-crs","dir":"Articles","previous_headings":"Summary","what":"Understanding Units and CRS","title":"hexsmoothR: Complete Guide to Hexagonal Grid Smoothing","text":"Coordinate Reference Systems: UTM coordinates: Use meters cell sizes (e.g., 20000 20km hexagons) WGS84 coordinates: Use degrees cell sizes (e.g., 0.1 ~11km hexagons) Functions automatically convert CRS needed Cell Size Units: cell_size parameter: Always units study area’s CRS UTM zones: cell_size meters (recommended real-world analysis) Geographic coordinates: cell_size degrees (use caution large areas) Smoothing Weights: Weights apply individual neighbor, neighbor means Center weight: Influence cell First-order weight: Influence immediate neighbor Second-order weight: Influence second-order neighbor Total influence depends number neighbors cell ","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Max M. Lang. Author, maintainer.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Max M. Lang (2024). hexsmoothR: Hexagonal Grid Smoothing Satellite Data. R package version 0.1.0. USGS Earth Resources Observation Science Center (2021). Landsat 8 Collection 2 Tier 1 Surface Reflectance. Google Earth Engine Data Catalog. https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2","code":"@Manual{,   title = {hexsmoothR: Hexagonal Grid Smoothing for Satellite Data},   author = {Max M. Lang},   year = {2024},   note = {R package version 0.1.0}, } @Article{,   title = {Landsat 8 Collection 2 Tier 1 Surface Reflectance},   author = {USGS {Earth Resources Observation and Science Center}},   year = {2021},   journal = {Google Earth Engine Data Catalog},   url = {https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2}, }"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"hexsmoothr-hexagonal-grid-smoothing-for-satellite-data","dir":"","previous_headings":"","what":"Hexagonal Grid Smoothing for Satellite Data","title":"Hexagonal Grid Smoothing for Satellite Data","text":"comprehensive R package creating hexagonal grids applying spatial smoothing satellite raster data. package specifically designed hexagonal grid analysis, providing tools extracting environmental variables TIF files applying Gaussian-weighted spatial smoothing using C++ optimization chunking support large datasets.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Hexagonal Grid Smoothing for Satellite Data","text":"Hexagonal Grid Creation: Create hexagonal grids study areas (primary focus) Spatial Topology: Compute neighbor relationships distances hexagonal grids Raster Processing: Efficient extraction values TIF files C++ Optimization: High-performance spatial smoothing algorithms Custom Weights: Flexible Gaussian weight parameters Multiple Formats: Support various raster formats projections Flexible Grid Input: Accepts sf POLYGON grid proper structure","code":""},{"path":[]},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"prerequisites","dir":"","previous_headings":"Installation","what":"Prerequisites","title":"Hexagonal Grid Smoothing for Satellite Data","text":"Windows users: need Rtools compile C++ code. Install https://cran.r-project.org/bin/windows/Rtools/ macOS users: Install Xcode Command Line Tools: xcode-select --install Linux users: Install build-essential: sudo apt-get install build-essential (Ubuntu/Debian) equivalent distribution.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"install-hexsmoothr","dir":"","previous_headings":"Installation","what":"Install hexsmoothR","title":"Hexagonal Grid Smoothing for Satellite Data","text":"","code":"# Install from GitHub devtools::install_github(\"MaxMLang/hexsmoothR\")  # Or install from local source install.packages(\"hexsmoothR_0.1.0.tar.gz\", repos = NULL, type = \"source\")"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"troubleshooting","dir":"","previous_headings":"Installation","what":"Troubleshooting","title":"Hexagonal Grid Smoothing for Satellite Data","text":"get compilation errors: Windows: Make sure Rtools installed PATH macOS: Ensure Xcode Command Line Tools installed Linux: Install build tools distribution platforms: Make sure latest version Rcpp: install.packages(\"Rcpp\")","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Hexagonal Grid Smoothing for Satellite Data","text":"","code":"library(hexsmoothR) library(sf) library(terra)  # Create hexagonal grid hex_grid <- create_grid(study_area, cell_size = 20000, type = \"hexagonal\")  # Compute spatial topology topology <- compute_topology(hex_grid)  # Extract raster data raster_files <- c(ndvi = \"path/to/ndvi.tif\", elevation = \"path/to/elevation.tif\") extracted_data <- extract_raster_data(raster_files, study_area, cell_size = 20000)  # Apply spatial smoothing smoothed_results <- smooth_variables(   variable_values = list(ndvi = extracted_data$data$ndvi, elevation = extracted_data$data$elevation),   neighbors = topology$neighbors,   weights = topology$weights,   var_names = c(\"ndvi\", \"elevation\") )"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"exported-functions","dir":"","previous_headings":"","what":"Exported Functions","title":"Hexagonal Grid Smoothing for Satellite Data","text":"hexsmoothR exports following public functions: create_grid - Create hexagonal square grids study areas compute_topology - Compute neighbor relationships spatial weights extract_raster_data - Extract values raster files grid cells smooth_variables - Apply spatial smoothing C++ optimization find_hex_cell_size_for_target_cells - Calculate optimal cell size target number cells get_utm_crs - Get appropriate UTM CRS study area hex_flat_to_edge - Convert hexagon measurements hex_edge_to_flat - Edge length flat--flat distance hex_flat_to_circumradius - Flat--flat circumradius conversion hex_circumradius_to_flat - Circumradius flat--flat conversion Note: Internal C++ R fallback functions exported called directly.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"grid-compatibility","dir":"","previous_headings":"","what":"Grid Compatibility","title":"Hexagonal Grid Smoothing for Satellite Data","text":"hexsmoothR works hexagonal grid required structure: Uber H3 grids Python/R Custom hexagonal grids Square grids (comparison) Required grid structure:","code":"grid <- st_sf(   geometry = st_sfc(polygons, crs = your_crs),   grid_id = unique_identifiers,      # Character vector   grid_index = 1:length(polygons)    # Numeric sequence )"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"output","dir":"","previous_headings":"","what":"Output","title":"Hexagonal Grid Smoothing for Satellite Data","text":"smoothing results contain: - raw - Weighted average center cell neighbors - neighbors_1st, neighbors_2nd, etc. - Mean neighbors order - weighted_combined - Final weighted average (recommended analysis)","code":""},{"path":[]},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"multiple-variables","dir":"","previous_headings":"Advanced Usage","what":"Multiple Variables","title":"Hexagonal Grid Smoothing for Satellite Data","text":"","code":"raster_files <- c(ndvi = \"path/to/ndvi.tif\", elevation = \"path/to/elevation.tif\") extracted_data <- extract_raster_data(raster_files, study_area, cell_size = 20000)  smoothed_results <- smooth_variables(   variable_values = list(ndvi = extracted_data$data$ndvi, elevation = extracted_data$data$elevation),   neighbors = topology$neighbors,   weights = topology$weights,   var_names = c(\"ndvi\", \"elevation\") )"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"custom-weights","dir":"","previous_headings":"Advanced Usage","what":"Custom Weights","title":"Hexagonal Grid Smoothing for Satellite Data","text":"","code":"topology <- compute_topology(hex_grid, neighbor_orders = 3, center_weight = 1.0)"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"grid-requirements","dir":"","previous_headings":"","what":"Grid Requirements","title":"Hexagonal Grid Smoothing for Satellite Data","text":"hexsmoothR works hexagonal grid follows required structure. can use grids created : Uber H3 grids Python, R, programming language Custom hexagonal grids created GIS software Grids packages (long follow structure ) Required grid structure: Example H3 grids Python: Tip: Use projected CRS (UTM) real-world analysis cell sizes meters.","code":"grid <- st_sf(   geometry = st_sfc(polygons, crs = your_crs),   grid_id = unique_identifiers,      # Character vector   grid_index = 1:length(polygons)    # Numeric sequence ) import h3 import geopandas as gpd from shapely.geometry import Polygon  # Create H3 hexagons in Python h3_hexes = h3.polygon_to_cells(polygon, resolution=8) geometries = [Polygon(h3.cell_to_boundary(hex_id)) for hex_id in h3_hexes]  # Convert to GeoDataFrame with required structure gdf = gpd.GeoDataFrame({     'grid_id': h3_hexes,     'grid_index': range(len(h3_hexes)) }, geometry=geometries, crs='EPSG:4326')"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"performance","dir":"","previous_headings":"","what":"Performance","title":"Hexagonal Grid Smoothing for Satellite Data","text":"C++ Optimization: High-performance spatial smoothing Memory Efficient: Chunking support large datasets Scalable: small areas continental scales","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"implementation-details","dir":"","previous_headings":"","what":"Implementation Details","title":"Hexagonal Grid Smoothing for Satellite Data","text":"hexsmoothR uses Rcpp high-performance spatial smoothing algorithms automatic fallback R implementation needed.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Hexagonal Grid Smoothing for Satellite Data","text":"Rcpp: C++ integration sf: Spatial data handling terra: Raster processing exactextractr: Efficient raster extraction data.table: Fast data manipulation","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"windows-specific-notes","dir":"","previous_headings":"","what":"Windows-Specific Notes","title":"Hexagonal Grid Smoothing for Satellite Data","text":"Important Windows users: hexsmoothR contains C++ code must compiled installation. requires: Rtools: Download install CRAN Rtools page Restart R/RStudio installing Rtools Verify installation: Run Sys.(\"make\") - return path, \"\"","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Hexagonal Grid Smoothing for Satellite Data","text":"Fork repository Create feature branch Make changes Add tests Submit pull request","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Hexagonal Grid Smoothing for Satellite Data","text":"MIT License - see LICENSE file details.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Hexagonal Grid Smoothing for Satellite Data","text":"","code":"@software{hexsmoothR2025,   title={hexsmoothR: Hexagonal Grid Smoothing for Satellite Data},   author={Max M. Lang},   year={2025},   url={https://github.com/maxmlang/hexsmoothR} }"},{"path":"https://maxmlang.github.io/hexsmoothR/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Hexagonal Grid Smoothing for Satellite Data","text":"issues questions: - Check vignettes: vignette(\"hexsmoothR-complete-guide\", package = \"hexsmoothR\") - Run examples: example(create_grid) - Report bugs GitHub","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_neighbors_n_orders.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute neighbors for N orders (internal function) — compute_neighbors_n_orders","title":"Compute neighbors for N orders (internal function) — compute_neighbors_n_orders","text":"Compute neighbors N orders (internal function)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_neighbors_n_orders.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute neighbors for N orders (internal function) — compute_neighbors_n_orders","text":"","code":"compute_neighbors_n_orders(grid_proj, neighbor_orders)"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_topology.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","title":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","text":"Finds spatial neighbors computes Gaussian-based weights smoothing. function determines grid cells neighbors specified orders (e.g., first-order neighbors touching, second-order neighbors neighbors), calculates appropriate weights based spatial distance using Gaussian decay.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_topology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","text":"","code":"compute_topology(   grid,   projection_crs = 32636,   neighbor_orders = 2,   sigma = NULL,   center_weight = 1,   neighbor_weights_param = NULL,   adaptive_sigma_factor = 0.5,   sample_size = 100 )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_topology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","text":"grid sf object polygonal geometries (hexagons squares) list sf objects. Must contain columns `grid_id` `grid_index`, created automatically. projection_crs CRS distance calculations (default UTM 36N). projected coordinate system (like UTM) accurate distance measurements meters. neighbor_orders Number neighbor orders compute (default 2). Higher orders provide extensive smoothing increase computation time memory usage. sigma Gaussian bandwidth parameter meters (NULL = auto-computed avg_distance * adaptive_sigma_factor). Controls quickly weights decay distance. center_weight Weight center cell (default 1.0). Higher values give influence original cell value. neighbor_weights_param Optional list weights neighbor order (overrides Gaussian computation). specified, must length equal `neighbor_orders`. Example: `list(0.5, 0.25)` 2 orders. adaptive_sigma_factor Scaling factor automatic sigma computation (default 0.5). Smaller values = less smoothing, larger values = smoothing. sample_size Number cells sample distance calculations (default 100). Used estimate average neighbor distance efficiently.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_topology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","text":"List containing: neighbors List lists, containing neighbor indices order weights List center_weight neighbor weights order (normalized) avg_distance Average distance neighboring cells meters sigma Gaussian bandwidth parameter used grid_ids Character vector grid cell identifiers grid_indices Integer vector grid cell indices neighbor_orders Number neighbor orders computed","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_topology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute spatial topology and weights for hexagonal smoothing — compute_topology","text":"**Weight Computation:** function uses Gaussian weights based spatial distance: - `sigma = avg_distance * adaptive_sigma_factor` (adaptive bandwidth) - Weights decay exponentially neighbor order: `exp(-order^2 / (2 * sigma^2))` - weights normalized sum 1 **weights applied smoothing:** - individual neighbor gets full weight (averaged) - Center cell: `value * center_weight` - neighbor order N: `value * neighbor_weight_order_N` - Final value = sum weighted values / sum weights used means cells neighbors get influence neighborhood, realistic spatial analysis.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_weights_n_orders.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute weights for N orders (internal function) — compute_weights_n_orders","title":"Compute weights for N orders (internal function) — compute_weights_n_orders","text":"Compute weights N orders (internal function)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/compute_weights_n_orders.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute weights for N orders (internal function) — compute_weights_n_orders","text":"","code":"compute_weights_n_orders(   neighbor_orders,   sigma,   center_weight,   weights_input,   avg_dist,   adaptive_sigma_factor )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create hexagonal or square grids for spatial analysis — create_grid","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"Creates regular hexagonal square grids study area. function automatically handles coordinate system transformations ensures proper grid alignment.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"","code":"create_grid(   study_area,   cell_size,   type = c(\"hexagonal\", \"square\"),   projection_crs = 32636,   id_column = NULL,   return_crs = 4326,   check_size = TRUE,   max_cells = 1e+06 )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"study_area sf object containing polygonal geometries defining study area. Can CRS - transformed `projection_crs` grid creation. cell_size Grid cell size. **UNITS DEPEND CRS:** - **Projected CRS (recommended)**: size METERS   - hexagons: flat--flat distance (width opposite edges)   - squares: side length - **Geographic CRS**: size DEGREES   - Use caution large areas due distortion type Character string: \"hexagonal\" (default) \"square\" projection_crs CRS grid creation (default UTM 36N). projected coordinate system accurate measurements. Use `get_utm_crs(study_area)` automatically determine appropriate UTM zone. id_column Optional column name `study_area` creating separate grids unique value. provided, returns named list grids. return_crs CRS output grid (default WGS84). Grid transformed CRS creation. check_size Whether warn grid large (default TRUE) max_cells Maximum number cells allowed stopping (default 1000000). Set NULL disable safety check entirely.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"sf object containing grid, named list sf objects `id_column` used.   grid cell contains: grid_id Unique identifier cell grid_index Sequential index (1 number cells) geometry Polygon geometry cell","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"**CRITICAL: Cell Size Units** `cell_size` parameter units depend coordinate reference system (CRS): - **Projected CRS (UTM, State Plane, etc.)**: `cell_size` **METERS**   - Example: `cell_size = 20000` creates 20km hexagons   - Example: `cell_size = 1000` creates 1km hexagons - **Geographic CRS (WGS84, NAD83, etc.)**: `cell_size` **DEGREES**   - Example: `cell_size = 0.1` creates ~11km hexagons   - Example: `cell_size = 0.01` creates ~1.1km hexagons **Recommended Practice:** Always use projected CRS (UTM) real-world analysis ensure accurate area calculations distance measurements. **Hexagon Measurements:** - `cell_size` represents **flat--flat distance** (width opposite edges) - Creates **pointy-topped hexagons** (flat sides horizontal) - intuitive measure represents \"width\" hexagon - Use helper functions `hex_flat_to_edge()` etc. convert measurements","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create hexagonal or square grids for spatial analysis — create_grid","text":"","code":"if (FALSE) { # \\dontrun{ library(sf)  # Create a simple study area study_area <- st_sf(geometry = st_sfc(   st_polygon(list(matrix(c(-5, 35, 5, 35, 5, 45, -5, 45, -5, 35), ncol = 2, byrow = TRUE))),   crs = 4326 ))  # Create 1km hexagonal grid (flat-to-flat distance = 1000m) hex_grid <- create_grid(study_area, cell_size = 1000, type = \"hexagonal\")  # Create 2km square grid (side length = 2000m)   square_grid <- create_grid(study_area, cell_size = 2000, type = \"square\")  # Create high-resolution grid with custom safety limit high_res_grid <- create_grid(study_area, cell_size = 100, type = \"hexagonal\", max_cells = 2000000) } # }"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_single_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Actually make the grid for one area — create_single_grid","title":"Actually make the grid for one area — create_single_grid","text":"Actually make grid one area","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/create_single_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Actually make the grid for one area — create_single_grid","text":"","code":"create_single_grid(   study_area,   grid_size,   type,   projection_crs,   return_crs,   area_id = NULL,   check_size = TRUE,   max_cells = 1e+06 )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/dot-onAttach.html","id":null,"dir":"Reference","previous_headings":"","what":"Package startup message (internal) — .onAttach","title":"Package startup message (internal) — .onAttach","text":"Package startup message (internal)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/dot-onAttach.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package startup message (internal) — .onAttach","text":"","code":".onAttach(libname, pkgname)"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/dot-onLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Package setup (internal) — .onLoad","title":"Package setup (internal) — .onLoad","text":"Package setup (internal)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/dot-onLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package setup (internal) — .onLoad","text":"","code":".onLoad(libname, pkgname)"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/extract_raster_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract raster data for a hex grid using exactextractr — extract_raster_data","title":"Extract raster data for a hex grid using exactextractr — extract_raster_data","text":"PRIMARY function extracting raster data hexagonal grids. automatically handles CRS transformations creates consistent hexagonal grids.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/extract_raster_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract raster data for a hex grid using exactextractr — extract_raster_data","text":"","code":"extract_raster_data(   raster_files,   study_area = NULL,   cell_size = NULL,   hex_grid = NULL,   sample_fraction = 1,   random_seed = 42 )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/extract_raster_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract raster data for a hex grid using exactextractr — extract_raster_data","text":"raster_files named vector raster file paths named list terra::rast objects study_area sf polygon (optional, cropping grid CRS reference) cell_size hex cell size (units target CRS - see details) hex_grid optional sf hexagonal grid use instead creating new one sample_fraction fraction raster cells use (default 1) random_seed reproducibility","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/extract_raster_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract raster data for a hex grid using exactextractr — extract_raster_data","text":"list: data frame cell_id, x, y, values raster","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/extract_raster_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract raster data for a hex grid using exactextractr — extract_raster_data","text":"**CRS Handling:** - `study_area` provided, function creates grid study area's CRS - `study_area` provided, function creates grid raster's CRS - function automatically crops rasters study area (provided) - coordinate transformations handled transparently **Grid Creation:** - Creates hexagonal grids using `sf::st_make_grid` robustness - Automatically adjusts cell sizes geographic coordinates (degrees) - Can use pre-existing grid via `hex_grid` parameter **Input Flexibility:** - Accepts file paths (character strings) `terra::rast` objects - passing `terra::rast` objects, can inspect CRS, dimensions, data extraction - Useful working -memory rasters pre-processed data **CRS Handling Details:** function intelligently handles coordinate reference systems: 1. **Study Area Provided**: Grid created study area's CRS    - Example: study_area UTM (EPSG:32630), grid uses UTM coordinates    - Cell sizes meters (e.g., 20000 20km hexagons) 2. **Study Area**: Grid created raster's CRS    - Example: raster WGS84 (EPSG:4326), grid uses geographic coordinates    - Cell sizes degrees (e.g., 0.1 ~11km hexagons) 3. **Automatic Adjustments**:    - Large cell sizes (>1) geographic coordinates trigger warnings    - Cell sizes automatically adjusted geographic coordinates needed **Input Types:** function accepts two types input `raster_files`: 1. **File Paths**: Named character vector file paths    “`r    raster_files = c(ndvi = \"path//ndvi.tif\", elevation = \"path//elevation.tif\")    “` 2. **Terra Raster Objects**: Named list terra::rast objects    “`r    # Load rasters first inspect    ndvi_rast <- rast(\"path//ndvi.tif\")    elev_rast <- rast(\"path//elevation.tif\") # Check CRS, dimensions, etc.    print(crs(ndvi_rast))    print(dim(ndvi_rast)) # Pass function    raster_files = list(ndvi = ndvi_rast, elevation = elev_rast)    “` **Workflow Recommendation:** consistent results, always provide `study_area` desired CRS: “`r # Create study area UTM accurate measurements study_area_utm <- st_transform(study_area_wgs, utm_crs) # Extract 20km hexagons (UTM coordinates) extracted <- extract_raster_data(   raster_files = c(var1 = \"path//raster.tif\"),   study_area = study_area_utm,   cell_size = 20000  # 20km meters ) # apply smoothing smoothed <- smooth_variables(...) “`","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/find_hex_cell_size_for_target_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal hexagonal cell size for target number of cells — find_hex_cell_size_for_target_cells","title":"Find optimal hexagonal cell size for target number of cells — find_hex_cell_size_for_target_cells","text":"Uses binary search find hexagonal cell size (flat--flat distance) produces approximately target number hexagons.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/find_hex_cell_size_for_target_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal hexagonal cell size for target number of cells — find_hex_cell_size_for_target_cells","text":"","code":"find_hex_cell_size_for_target_cells(   study_area,   target_cells,   cell_size_min = 0.001,   cell_size_max = 10,   tol = 0.05,   max_iter = 20 )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/find_hex_cell_size_for_target_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal hexagonal cell size for target number of cells — find_hex_cell_size_for_target_cells","text":"study_area sf object (polygons) target_cells target number hexagons cell_size_min minimum cell size try (map units) cell_size_max maximum cell size try (map units) tol tolerance convergence (fraction target_cells) max_iter maximum iterations binary search","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/find_hex_cell_size_for_target_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal hexagonal cell size for target number of cells — find_hex_cell_size_for_target_cells","text":"cell size (flat--flat distance) gives closest target_cells hexagons","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/get_utm_crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Get appropriate UTM CRS for a study area — get_utm_crs","title":"Get appropriate UTM CRS for a study area — get_utm_crs","text":"Automatically determines appropriate UTM coordinate reference system (CRS) given study area based centroid location.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/get_utm_crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get appropriate UTM CRS for a study area — get_utm_crs","text":"","code":"get_utm_crs(study_area)"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/get_utm_crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get appropriate UTM CRS for a study area — get_utm_crs","text":"study_area sf object representing study area","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/get_utm_crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get appropriate UTM CRS for a study area — get_utm_crs","text":"Character string UTM CRS (e.g., \"EPSG:32630\" UTM zone 30N)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/get_utm_crs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get appropriate UTM CRS for a study area — get_utm_crs","text":"","code":"if (FALSE) { # \\dontrun{ library(sf)  # Create a simple study area study_area <- st_sf(geometry = st_sfc(   st_polygon(list(matrix(c(-5, 35, 5, 35, 5, 45, -5, 45, -5, 35), ncol = 2, byrow = TRUE))),   crs = 4326 ))  # Get appropriate UTM CRS utm_crs <- get_utm_crs(study_area) print(utm_crs)  # Should return something like \"EPSG:32630\" } # }"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between hexagon measurements — hex_flat_to_edge","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"Helper functions convert different hexagon measurements: flat--flat distance, edge length, circumradius (center vertex).","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"","code":"hex_flat_to_edge(flat_to_flat)  hex_flat_to_circumradius(flat_to_flat)  hex_edge_to_flat(edge_length)  hex_circumradius_to_flat(circumradius)"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"flat_to_flat Flat--flat distance (distance opposite edges) edge_length Edge length hexagon circumradius Circumradius hexagon","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"Numeric value units input","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"Convert hexagon measurements functions convert different hexagon measurements: - `hex_flat_to_edge`: Convert flat--flat distance edge length - `hex_flat_to_circumradius`: Convert flat--flat distance circumradius - `hex_edge_to_flat`: Convert edge length flat--flat distance - `hex_circumradius_to_flat`: Convert circumradius flat--flat distance","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/hex_flat_to_edge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between hexagon measurements — hex_flat_to_edge","text":"","code":"# Convert 1000m flat-to-flat to edge length hex_flat_to_edge(1000)  # Returns ~577.35m #> [1] 577.3503  # Convert 1000m flat-to-flat to circumradius   hex_flat_to_circumradius(1000)  # Returns ~577.35m #> [1] 577.3503  # Convert 577.35m edge length to flat-to-flat hex_edge_to_flat(577.35)  # Returns ~1000m #> [1] 999.9995  # Convert 577.35m circumradius to flat-to-flat hex_circumradius_to_flat(577.35)  # Returns ~1000m #> [1] 999.9995"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/process_district_all_vars_n_orders_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"C++ wrapper for N-order smoothing (internal) — process_district_all_vars_n_orders_wrapper","title":"C++ wrapper for N-order smoothing (internal) — process_district_all_vars_n_orders_wrapper","text":"C++ wrapper N-order smoothing (internal)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/process_district_all_vars_n_orders_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"C++ wrapper for N-order smoothing (internal) — process_district_all_vars_n_orders_wrapper","text":"","code":"process_district_all_vars_n_orders_wrapper(   variable_values,   neighbors,   weights,   hex_indices,   var_names )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/process_district_all_vars_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"C++ wrapper for 2-order smoothing (internal) — process_district_all_vars_wrapper","title":"C++ wrapper for 2-order smoothing (internal) — process_district_all_vars_wrapper","text":"C++ wrapper 2-order smoothing (internal)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/process_district_all_vars_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"C++ wrapper for 2-order smoothing (internal) — process_district_all_vars_wrapper","text":"","code":"process_district_all_vars_wrapper(   variable_values,   first_neighbors,   second_neighbors,   weights,   hex_indices,   var_names )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","title":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","text":"function applies spatial smoothing variables using hexagonal grid topology. can used independently data extraction, part complete workflow. function automatically uses C++ implementation available falls back R needed.","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","text":"","code":"smooth_variables(   variable_values,   neighbors,   weights,   hex_indices = NULL,   var_names )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","text":"variable_values List numeric vectors containing variable values grid cell neighbors List neighbor indices order (compute_topology) weights List containing center_weight neighbor_weights order hex_indices Vector hexagon indices process (default: cells) var_names Character vector variable names","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","text":"List containing smoothing results variable following components: raw: Weighted average center cell neighbors neighbors_Nst: Mean neighbors order N weighted_combined: Weighted average center cell neighbors","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply spatial smoothing to variables using hexagonal grid topology — smooth_variables","text":"","code":"# After creating a grid and computing topology # grid_sf <- create_grid(study_area, cell_size = 10000) # topology <- compute_topology(grid_sf, neighbor_orders = 3)  # 3 orders  # Extract your variables (example) # variable_values <- list( #   ndvi = c(0.5, 0.6, 0.4, 0.7, 0.3), #   elevation = c(100, 120, 90, 140, 80) # )  # Apply smoothing with N orders # smoothing_results <- smooth_variables( #   variable_values = variable_values, #   neighbors = topology$neighbors, #   weights = topology$weights, #   var_names = c(\"ndvi\", \"elevation\") # )"},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables_r_fallback.html","id":null,"dir":"Reference","previous_headings":"","what":"R fallback smoothing function (internal) — smooth_variables_r_fallback","title":"R fallback smoothing function (internal) — smooth_variables_r_fallback","text":"R fallback smoothing function (internal)","code":""},{"path":"https://maxmlang.github.io/hexsmoothR/reference/smooth_variables_r_fallback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R fallback smoothing function (internal) — smooth_variables_r_fallback","text":"","code":"smooth_variables_r_fallback(   variable_values,   neighbors,   weights,   hex_indices,   var_names )"}]
